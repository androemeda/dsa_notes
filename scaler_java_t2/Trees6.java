public class Trees6 {

    /**
     * Q.given an array which was sorted initially but 2 values got swapped. return the 2 values.
     * Ex: 3,4,14,10,11,7,17,19 : ans = [14,7]
     * TC : O(N) --> compare every value with next value. keep 2 adjacent pointers and check for anomolies.
     *               if 2 anomolies -->
     *               if 1 anomoly --> 2 consecutive elements are swapped 
     */

    /**
     * Q. given a BST where 2 nodes have been swapped. fix it(swap the values).
     * 
     * solve without storing the values
     * 
     * you get 1 anomoly when you swap element with its inorder predecessor. the nodes might not be adjacent in the tree.
     * 
     * leetcode - 99.
     */

    /**
     * GOOGLE
     * Q. Given a complete binary tree (all levels except the last level must completely filled. if last level is partially filled , it should be strictly filled from left to right)
     * 
     * to be done in TC strictly less than O(N).
     */
    
    public static void main(String[] args){

    }
}

/**
 * Self-Balacing BST
 *  AVL tree
 *  red-black tree
 */

/**
 * hw - create a simple hashMap
 */

/**
 * what is difference between hashMap till java7 and java8
 * ans - java7 - uses linkedList inside hence un-optimal
 *       java8 - uses red-black tree inside hence optimal
 */

/**
 * explore TreeSet and TreeMap
 * find ceil , floor , max , min , delete - these operations are optimal in these
 */